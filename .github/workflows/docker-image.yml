name: Deploy to Droplet
on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

env:
  DOCKER_IMAGE_NAME: website
  HEALTH_CHECK_RETRIES: 15
  HEALTH_CHECK_INTERVAL: 2
  CADDY_PATH: /etc/caddy

jobs:
  deploy:
    runs-on: ubuntu-latest
    concurrency:
      group: production_environment
      cancel-in-progress: false

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add host key to known_hosts
        run: ssh-keyscan -H ${{ secrets.DROPLET_IP }} >> ~/.ssh/known_hosts

      - name: Build Docker image with metadata
        run: |
          docker build \
            --build-arg VERSION=$(date +%s) \
            --label org.opencontainers.image.revision=${{ github.sha }} \
            -t ${{ env.DOCKER_IMAGE_NAME }}:latest .

      - name: Save Docker image
        run: |
          docker save ${{ env.DOCKER_IMAGE_NAME }}:latest | gzip > ${{ env.DOCKER_IMAGE_NAME }}.tar.gz

      - name: Determine active deployment and create deploy folder
        id: config
        run: |
          DEPLOY_FOLDER="deploy_$(date +%s)"
          ssh ${{ secrets.SSH_USER }}@${{ secrets.DROPLET_IP }} "mkdir -p ~/$DEPLOY_FOLDER"
          echo "deploy_folder=$DEPLOY_FOLDER" >> $GITHUB_ENV
          
          ACTIVE_CONFIG=$(ssh ${{ secrets.SSH_USER }}@${{ secrets.DROPLET_IP }} 'sudo readlink ${{ env.CADDY_PATH }}/Caddyfile | grep -q "blue" && echo "blue" || echo "green"')
          
          if [ "$ACTIVE_CONFIG" = "blue" ]; then
            TARGET_CONFIG="green"
            TARGET_PORT=8081
          else
            TARGET_CONFIG="blue"
            TARGET_PORT=8080
          fi
          
          echo "active_config=$ACTIVE_CONFIG" >> $GITHUB_OUTPUT
          echo "target_config=$TARGET_CONFIG" >> $GITHUB_OUTPUT
          echo "target_port=$TARGET_PORT" >> $GITHUB_OUTPUT

      - name: Transfer image to Droplet
        run: |
          scp ${{ env.DOCKER_IMAGE_NAME }}.tar.gz ${{ secrets.SSH_USER }}@${{ secrets.DROPLET_IP }}:~/${{ env.deploy_folder }}/

      - name: Load Docker image on host
        run: |
          ssh ${{ secrets.SSH_USER }}@${{ secrets.DROPLET_IP }} "cd ~/${{ env.deploy_folder }} && \
            gunzip -c ${{ env.DOCKER_IMAGE_NAME }}.tar.gz | docker load && \
            rm ${{ env.DOCKER_IMAGE_NAME }}.tar.gz"

      - name: Create Docker network if it doesn't exist
        run: |
          ssh ${{ secrets.SSH_USER }}@${{ secrets.DROPLET_IP }} "docker network inspect web-network >/dev/null 2>&1 || docker network create web-network"

      - name: Clean up previous containers with target config
        run: |
          ssh ${{ secrets.SSH_USER }}@${{ secrets.DROPLET_IP }} "docker ps -a --filter name=website-${{ steps.config.outputs.target_config }} -q | xargs -r docker rm -f"
          sleep 2

      - name: Run new container
        id: deploy
        run: |
          VERSION=$(date +%s)
          
          PORT_IN_USE=$(ssh ${{ secrets.SSH_USER }}@${{ secrets.DROPLET_IP }} "netstat -tuln | grep :${{ steps.config.outputs.target_port }} > /dev/null && echo 'true' || echo 'false'")
          if [ "$PORT_IN_USE" = "true" ]; then
            ssh ${{ secrets.SSH_USER }}@${{ secrets.DROPLET_IP }} "docker ps -q --filter publish=${{ steps.config.outputs.target_port }} | xargs -r docker rm -f"
            sleep 2
          fi
          
          if ssh ${{ secrets.SSH_USER }}@${{ secrets.DROPLET_IP }} "docker run -d \
          --restart unless-stopped \
          --network web-network \
          -p ${{ steps.config.outputs.target_port }}:8080 \
          --env PORT=8080 \
          --env COMMIT_SHA=${{ github.sha }} \
          --name website-${{ steps.config.outputs.target_config }}-$(date +%s) \
          --cap-drop=ALL \
          --security-opt no-new-privileges=true \
          ${{ env.DOCKER_IMAGE_NAME }}:latest"; then
            echo "container_id=$(ssh ${{ secrets.SSH_USER }}@${{ secrets.DROPLET_IP }} "docker ps -q --filter name=website-${{ steps.config.outputs.target_config }}")" >> $GITHUB_OUTPUT
            echo "deployment_success=true" >> $GITHUB_OUTPUT
          else
            echo "deployment_success=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Check health of new container
        id: health_check
        run: |
          ssh ${{ secrets.SSH_USER }}@${{ secrets.DROPLET_IP }} "\
            for i in \$(seq 1 ${{ env.HEALTH_CHECK_RETRIES }}); do \
              if curl -s --fail http://localhost:${{ steps.config.outputs.target_port }}/health > /dev/null; then \
                exit 0; \
              fi; \
              sleep ${{ env.HEALTH_CHECK_INTERVAL }}; \
            done; \
            exit 1"
          
          if [ $? -eq 0 ]; then
            echo "health_status=passed" >> $GITHUB_OUTPUT
          else
            echo "health_status=failed" >> $GITHUB_OUTPUT
          fi

      - name: Switch traffic to new deployment
        if: steps.health_check.outputs.health_status == 'passed'
        run: |
          ssh ${{ secrets.SSH_USER }}@${{ secrets.DROPLET_IP }} "\
            sudo ln -sf ${{ env.CADDY_PATH }}/Caddyfile.${{ steps.config.outputs.target_config }} ${{ env.CADDY_PATH }}/Caddyfile && \
            sudo docker compose -f ${{ env.CADDY_PATH }}/docker-compose.yml restart"

      - name: Rollback deployment
        if: steps.health_check.outputs.health_status == 'failed'
        run: |
          if [ "${{ steps.deploy.outputs.deployment_success }}" == "true" ]; then
            ssh ${{ secrets.SSH_USER }}@${{ secrets.DROPLET_IP }} "docker rm -f ${{ steps.deploy.outputs.container_id }}"
          fi
          exit 1

      - name: Clean up old containers (after successful switch)
        if: steps.health_check.outputs.health_status == 'passed'
        run: |
          ssh ${{ secrets.SSH_USER }}@${{ secrets.DROPLET_IP }} "\
            docker ps --filter 'name=website-${{ steps.config.outputs.active_config }}' -q | xargs -r docker rm -f"

      - name: Clean up unused Docker resources
        if: always()
        run: |
          ssh ${{ secrets.SSH_USER }}@${{ secrets.DROPLET_IP }} "\
            rm -rf ~/${{ env.deploy_folder }} && \
            docker system prune -f --volumes > /dev/null 2>&1"